---
title: 1.3 Multi-attention Head
type: docs
---

*Finding relations between tokens.*

<img src="/img/transformer-vaswani.png" alt="The Transformer" width="50%"/>

During utilisation, attention regards finding how strongly tokens are interrelated, based on specific types of relations.  
For example, in the context of translation, words cannot be translated word-by-word independently, due to differences in sentence structures across languages, such as English's subject-verb-object pattern compared to the subject-object-verb pattern found in other languages (e.g. Japanese). Instead, the grammatical relations between the words must first be understood.

Mathematically, a single self-attention mechanism head calculates attention scores as follows:  
\(attention(Q, K, V) = softmax( \frac {QK^{T}} {\sqrt {d_{k}} } + M) \cdot V \)

Note the use of the dot product, which mathematically tends to feature in vector manipulations, because the inputs (tokens) are essentially being represented as vectors (in matrix **Q**) in potentially a dimension outside of reality (e.g. 2048 dimensions), and then compared to the metadata of the other tokens (in matrix **K**) also stored as vectors of the same dimension. The result of the dot product will then indicate the best matching token meanings (represented as numbers, in matrix **V**).

This self-attention mechanism can be broken down into a step-by-step sequence:

1. All the input vectors x<sub>i</sub> (such as those output from the positional encoding step), are set into a matrix **X**; for example 6 input vectors of dimension 4 would be arranged as a 6x4 matrix.  


|  <!-- -->  |   <!-- -->  |   <!-- -->  |   <!-- -->  |  <!-- -->  | 
| :---- | :---- | :---- | :---- | :---- |
| \(x_{1}\) | 0.1 | -0.2 | 0.1 | 0.2 |
| \(x_{2}\) | 0.8 | 0.8 | -0.9 | 0.5 |
| \(x_{3}\) | -0.6 | 0.4 | 0.5 | -0.9 |
| \(x_{4}\) | 0.9 | -0.7 | 0.8 | 0.7 |
| \(x_{5}\) | 0.4 | 0.3 | 0.4 | 0.4 |
| \(x_{6}\) | 0.8 | 0.2 | 0.9 | -0.2 |

*Sample matrix **X** above could represent an input such as the sentence "List new ideas for a song", one word per **x**<sub>i</sub> row, in the simple case of 4 dimensions per token.*


2. The matrix **X** is multiplied by 3 weight matrices of equivalent dimensions (for the dimensions in this example: 4x4), one matrix **W<sup>Q</sup>** representing query weights, one matrix **W<sup>K</sup>** representing key weights, and one matrix **W<sup>V</sup>** representing value weights, to generate three new matrices **Q**, **K**, and **V**.  

**Q** = **XW<sup>Q</sup>**

**K** = **XW<sup>K</sup>**

**V** = **XW<sup>V</sup>**


|  <!-- -->  |   <!-- -->  |   <!-- -->  |   <!-- -->  | 
| :---- | :---- | :---- | :---- |
| 3.4 | -2.1 | 0.8 | 1.9 |
| -1.2 | 0.5 | 3.7 | -0.8 |
| 2.9 | 1.1 | -3.4 | 0.6 |
| 0.7 | 2.8 | 1.3 | -2.5 |

*Sample matrix **W<sup>Q</sup>** above.*

|  <!-- -->  |   <!-- -->  |   <!-- -->  |   <!-- -->  |   <!-- -->  | 
| :---- | :---- | :---- | :---- | :---- |
| \(q_{1}\) | 1.01 | 0.36 | -0.74 | -0.09 |
| \(q_{2}\) | -0.50 | -0.87 | 4.49 | -0.23 |
| \(q_{3}\) | 2.17 | -1.99 | -3.92 | 1.71 |
| \(q_{4}\) | 1.43 | 2.59 | 1.97 | -3.19 |
| \(q_{5}\) | 0.67 | 0.98 | 0.61 | -0.31 |
| \(q_{6}\) | 1.97 | 0.52 | 4.01 | -0.51 |

*Sample matrix **Q** above.*

3. The dot product of each query vector **q**<sub>i</sub> (a query vector being a row of **Q**) with every key ki via transposed **KT** is calculated, to generate attention scores; \(\ QK^{T} \).  
   Higher attention scores between a given **q**<sub>i</sub> and a given **k**<sub>i</sub> indicaŧe that the query **q**<sub>i</sub> is more similar to the given **k**<sub>i</sub>, and therefore that there is a stronger relation.  

attention(**Q**, **K**) = **QK<sup>T</sup>**

|  <!-- -->  |   <!-- -->  |   <!-- -->  |   <!-- -->  |   <!-- -->  |  <!-- -->  | 
| :---- | :---- | :---- | :---- | :---- | :---- |
| 0.15 | 1.94 | -0.98 | 2.53 | 1.24 | 2.18 |
| 0.16 | 1.44 | 0.64 | -2.33 | 0.81 | 0.44 |
| 0.25 | 0.35 | 1.25 | 2.24 | 1.14 | 3.25 |
| 0.28 | 1.15 | -0.81 | 1.93 | -0.81 | -0.28 |

*Sample matrix **K<sup>T</sup>** above.*


| 0. | 0. | 0. | 0. | 0. | 0. |
| :---- | :---- | :---- | :---- | :---- | :---- |
| 0. | 0. | 0. | 0. | 0. | 0. |
| 0. | 0. | 0. | 0. | 0. | 0. |
| 0. | 0. | 0. | 0. | 0. | 0. |
| 0. | 0. | 0. | 0. | 0. | 0. |
| 0. | 0. | 0. | 0. | 0. | 0. |

*Sample matrix **QK<sup>T</sup>** above.*

4. These attention scores are then normalised by dividing by the square root of the dimension being used (in this example, 4); \(\frac {QK^{T}}{\sqrt{d_{k}}}\).

5. In the decoder, a masking matrix **M** is used to force infinitely negative attention scores between tokens being queried and future tokens, such that only attention scores between a given token and tokens previously generated are used; \( \frac {QK^{T}}{\sqrt{d_{k}}} + M \).

| _ | _ | _ | _ | _ | _ |
| :---- | :---- | :---- | :---- | :---- | :---- |
| _ | _ | _ | _ | _ | \-∞ |
| _ | _ | _ | _ | \-∞ | \-∞ |
| _ | _ | _ | \-∞ | \-∞ | \-∞ |
| _ | _ | \-∞ | \-∞ | \-∞ | \-∞ |
| _ | \-∞ | \-∞ | \-∞ | \-∞ | \-∞ |

*Matrix … in the case of* 

6. Softmax is run on the attention scores, nullifying the infinitely negative scores, and generating a probability distribution from the attention scores; \( softmax ( \frac {QK^{T}}{\sqrt{d_{k}}} +M) \).

| _ | _ | _ | _ | _ | _ |
| :---- | :---- | :---- | :---- | :---- | :---- |
| _ | _ | _ | _ | _ | _ |
| _ | _ | _ | _ | _ | _ |
| _ | _ | _ | _ | _ | _ |
| _ | _ | _ | _ | _ | _ |
| _ | _ | _ | _ | _ | _ |

*After softmax() is applied, in the resulting matrix the cells in each column will add up to 1*

7. The probability distribution is then applied to the values within **V** to find the input tokens with the largest influence on the token under focus.

| v1 | _ | _ | _ | _ |
| :---- | :---- | :---- | :---- | :---- |
| v2 | _ | _ | _ | _ |
| v3 | _ | _ | _ | _ |
| v4 | _ | _ | _ | _ |
| v5 | _ | _ | _ | _ |
| v6 | _ | _ | _ | _ |

| _ | _ | _ | _ |
| :---- | :---- | :---- | :---- |
| _ | _ | _ | _ |
| _ | _ | _ | _ |
| _ | _ | _ | _ |
| _ | _ | _ | _ |
| _ | _ | _ | _ |

*Above: final matrix dimension*

Notes regarding the above example matrices:

* a matrix WK is of size 4x4 means that there are 4 keys stored within the self-attention mechanism, each with a level of detail of dimension 4  
* approximately all the cells have been left blank, because although every cell would contain a number in a working implementation, the numbers hold no meaning to humans, and so they have been omitted for readability  
* in modern LLM implementations, the dimensions of the key, value, and initial inputs to the Transformer may differ in dimensionality

More algebraic, implicit examples of the matrix transformations are available at:  
https://www.columbia.edu/\~jsl2239/transformers.html  
https://web.stanford.edu/\~jurafsky/slp3/9.pdf

The multi-head attention layer works largely similarly to a single self-attention as above, but the multiple instances of the heads mean that there are multiple instances of the **\(W^{**Q, **\(W^{**K, and **\(W^{**V matrices, such that the weights within each set of (WQ, WK, WV) possess different focuses.  
For example, one self-attention head may be oriented around finding grammatical relations between tokens, a different head may focus on finding tense-based relations between tokens, whilst a different head may focus on syntactic relations between tokens.  
As a more specific example, a **Q** matrix in one head may be focusing on whether there are adjectives/adverbs relating to each token within the input sequence (presuming **\(W^{**Q was trained with such a focus).

Transformers are typically trained end-to-end (all layers trained at once), using specific word-oriented problems. So, before training, the weights within the matrices of a self-attention head \- **\(W^{**Q, **\(W^{**K, **\(W^{**V \- all initialised at random, then specific training tasks and loss functions are used to refine all parameters within the model, including the weights within each self-attention mechanism. These loss functions are covered in LLM Deep Dive from Springer.

Modern GPUs are able to derive attention scores for one input sequence across multiple heads, simultaneously. This means, for an input sequence n, there may be O(n2) matrices output, each matrix signifying the relations between one token and the other tokens within the input sequence.
